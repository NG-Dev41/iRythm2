import { ChangeDetectorRef, Component, ElementRef, OnDestroy, OnInit, ViewChild, ViewChildren } from '@angular/core';
import { Observable, startWith, Subject, Subscription } from 'rxjs';
import { RecordDto } from 'app/features/record/services/dtos/record-dto.service';
import { select, Store } from '@ngrx/store';
import { addFindingAction, deleteFindingAction, retrieveFindingsAction, updateFindingAction } from 'app/store/actions';
import { selectFindings, selectKeyValueMap } from 'app/store/selectors';
import { FindingsType, IFinding } from 'app/commons/services/dao/process-data-dao.service';
import { FormControl } from '@angular/forms';
import { map, tap } from 'rxjs/operators';
import { MatAutocompleteSelectedEvent, MatAutocompleteTrigger } from '@angular/material/autocomplete';
import { TranslateService } from '@ngx-translate/core';

@Component({
    selector: 'tqa-record-report-prep-preliminary-findings',
    templateUrl: './record-report-prep-preliminary-findings.component.html',
    styleUrls: ['./record-report-prep-preliminary-findings.component.scss'],
})
export class RecordReportPrepPreliminaryFindingsComponent implements OnInit, OnDestroy {
    @ViewChild(MatAutocompleteTrigger, { read: MatAutocompleteTrigger }) autocompleteInput: MatAutocompleteTrigger;
    @ViewChildren('findingsTextArea') editingTextArea: ElementRef<HTMLTextAreaElement>[];

    public ReportPreviewSearchBarControl = new FormControl('');

    // Processed findings
    public findings$: Observable<Array<IFinding>>;

    // List of findings from the Findings reducer
    public currentFindings: Array<IFinding>;

    public keyValueMap$: Observable<{ [p: string]: string }>;

    // All of the possible findings the user can select from the search
    public possibleUserFindings: { key: string; value: string }[];

    // The possible user findings after filtering for the user input
    public filteredPossibleUserFindings: Subject<{ key: string; value: string }[]> = new Subject();

    // A list of key-boolean pairs to keep track of whether a finding is editable or not
    // Non-user findings can never be editable
    // user findings can be toggled between an editable and not-editable state
    public isEditableMap: Map<string, boolean> = new Map();

    // for use in template
    public FindingsType = FindingsType;

    private readonly MANUAL_FINDINGS_TRANSLATE_PREFIX: string = 'report.findings.manual';

    private allSubscriptions: Subscription = new Subscription();

    /**
     * Ctor
     *
     * @param  private recordDto
     * @param      private storeService
     */
    public constructor(
        private recordDto: RecordDto,
        private storeService: Store,
        private translateService: TranslateService,
        private cdRef: ChangeDetectorRef
    ) {}

    /**
     * Kick off the action to retrieve the findings
     */
    public ngOnInit(): void {
        this.allSubscriptions.add(
            this.translateService
                .get(this.MANUAL_FINDINGS_TRANSLATE_PREFIX)
                .pipe(
                    map((translations: { [s: string]: string }) =>
                        Object.keys(translations).map((findingsKey) => ({
                            key: findingsKey,
                            value: translations[findingsKey],
                        }))
                    )
                )
                .subscribe((translations: { key: string; value: string }[]) => (this.possibleUserFindings = translations))
        );

        // Load the autogenerated findings
        // Refresh the searchBar findings to remove duplicates found in the new autogenerated findings
        this.findings$ = this.storeService.pipe(
            select(selectFindings),
            tap((findings: Array<IFinding>) => {
                findings.forEach((finding) => {
                    if (finding.findingsType === FindingsType.USER_DEFINED) {
                        if (this.isEditableMap.get(finding.key)) {
                            this.isEditableMap.set(finding.key, this.isEditableMap.get(finding.key));
                        } else {
                            this.isEditableMap.set(finding.key, false);
                        }
                    } else {
                        this.isEditableMap.set(finding.key, false);
                    }
                });
                // Save this to use in the filterUserFindings function
                this.currentFindings = findings;
                this.filteredPossibleUserFindings.next(this.filterUserFindings(this.ReportPreviewSearchBarControl.value));
                this.cdRef.detectChanges();
            })
        );

        this.keyValueMap$ = this.storeService.pipe(select(selectKeyValueMap));

        // Filter the searchbar findings to reflect the current search bar value
        this.allSubscriptions.add(
            this.ReportPreviewSearchBarControl.valueChanges.pipe(startWith('')).subscribe((value) => {
                this.filteredPossibleUserFindings.next(this.filterUserFindings(value || ''));
            })
        );

        this.storeService.dispatch(retrieveFindingsAction({ serialNumber: this.recordDto.serialNumber }));
    }

    /**
     * Filters the searchbarFindings autocomplete to reflect the value in the searchbar
     *
     * @param searchBarValue
     * @private
     */
    public filterUserFindings(searchBarValue: string): { key: string; value: string }[] {
        const findingsList = this.possibleUserFindings.filter(
            (finding) => !this.currentFindings?.map((currentFinding) => currentFinding.key).includes(finding.key)
        );
        if (searchBarValue === undefined) {
            return findingsList;
        }

        const filterValue = searchBarValue
            .toLowerCase()
            .split(' ')
            .filter((word) => word !== '');
        if (filterValue.length === 0 || (filterValue.length === 1 && filterValue[0] === '')) {
            return findingsList;
        }

        return findingsList.filter((templateLine) => {
            const templateLineArray = templateLine.value
                .toLowerCase()
                .split(' ')
                .filter((word) => word !== '');
            if (searchBarValue.endsWith(' ')) {
                return filterValue.every((filterWord) => templateLineArray.includes(filterWord));
            } else {
                const allButLastFilterValue = filterValue.slice(0, -1);
                const lastFilterValue = filterValue.slice(-1)[0];
                return (
                    allButLastFilterValue.every((filterWord) => templateLineArray.includes(filterWord)) &&
                    templateLineArray.some((word) => word.startsWith(lastFilterValue))
                );
            }
        });
    }

    /**
     * Clears the searcbar and stops the click event from refocusing on the search bar
     *
     * @param $event
     */
    public resetAutocomplete($event: Event) {
        $event.stopPropagation();
        $event.stopImmediatePropagation();
        this.clearSearchInput();
    }

    /**
     * Adds the selected finding to the findingsList
     *
     * @param $event
     */
    public addFindingToList($event: MatAutocompleteSelectedEvent) {
        $event.option.deselect();
        const value: string = $event.option.value as string;
        const key: string = this.possibleUserFindings[this.possibleUserFindings.findIndex((finding) => finding.value === value)].key;

        this.storeService.dispatch(
            addFindingAction({
                content: value,
                key,
                serialNumber: this.recordDto.serialNumber,
            })
        );

        this.clearSearchInput();
    }

    /**
     * Function to comply with the mat-autocomplete displayWith input
     * Returns null so that the search bar does not autofill after a value is selected
     *
     * @param finding
     */
    public displayNull(finding: string) {
        return null;
    }

    /**
     * Sets the finding to be in the Editable state
     * Editable state is where the user can edit the content of the finding
     *
     * @param key
     * @param isEditable
     */
    public setEditable(key: string, isEditable: boolean, findingsType: FindingsType): void {
        // Non user defined findings can not be edited
        if (findingsType !== FindingsType.USER_DEFINED) {
            return;
        }
        this.isEditableMap.set(key, isEditable);
        // Run manually to clear disabled flag, otherwise we can't set focus
        this.cdRef.detectChanges();
        // Find the editable element to set focus, there should be only one--like Highlander--but grab the first
        const eta: ElementRef<HTMLTextAreaElement> = this.editingTextArea.filter((textarea) => textarea.nativeElement.disabled === false)[0];
        this.setFocus(eta);
    }

    private setFocus(elementRef: ElementRef<HTMLTextAreaElement>): void {
        // Find length to set selection range, essentially put cursor at end since double click really wants to select text
        const textareaValueLength = elementRef.nativeElement.value?.length;
        elementRef.nativeElement.setSelectionRange(textareaValueLength, textareaValueLength);
        elementRef.nativeElement.focus();
    }

    /**
     * Updates finding content with new content
     *
     * @param key
     */
    public updateFinding(key: string) {
        const reportFinding: HTMLTextAreaElement = document.getElementById(key) as HTMLTextAreaElement;

        let value = reportFinding.value;

        // Clean up input
        value = this.cleanUpInputValue(value);

        this.storeService.dispatch(
            updateFindingAction({
                content: value,
                key,
                serialNumber: this.recordDto.serialNumber,
            })
        );

        this.isEditableMap.set(key, false);
    }

    /**
     * Removes multiple spaces and newlines from the textAreaInput
     *
     * @param value
     */
    public cleanUpInputValue(value: string): string {
        return value
            .replace(/\n/g, ' ')
            .trim()
            .split(' ')
            .filter((word) => word !== '')
            .join(' ');
    }

    /**
     * Deletes finding from finding list.
     *
     * @param key
     */
    public deleteFinding(key: string) {
        this.storeService.dispatch(
            deleteFindingAction({
                key,
                serialNumber: this.recordDto.serialNumber,
            })
        );
    }

    public ngOnDestroy(): void {
        this.allSubscriptions.unsubscribe();
    }


    /**
     * Clears and resets the searchbar
     *
     * @private
     */
    private clearSearchInput() {
        this.ReportPreviewSearchBarControl.setValue('');
        setTimeout(() => (document.activeElement as HTMLElement)?.blur(), 0);
        this.autocompleteInput.closePanel();
    }
}
